# RFC 004: Blitz Session Management

## Objectives
1) Enable login and logout functionality.
2) Ability to easily set session inactivity timeout length (potentially for an "infinite" amount of time).
3) Easy to use
4) By default, prevent against:
    - CSRF: Can be switch off on a per endpoint basis.
    - XSS
    - Brute force
    - Database session theft: Even if an attacker gets the session tokens from the db, they should not be able to hijack those user's accounts.
5) Optionally provide significantly more security by detecting token theft as per [this RFC](https://tools.ietf.org/html/rfc6749#section-10.4). This will be inspired by [SuperTokens.io](https://supertokens.io?s=bl)'s implementation of sessions. [Here](https://docs.google.com/spreadsheets/d/14h9qd2glE31HSGUofx43XwfJHZNzgkdCwEKl-3UcXLE/edit?usp=sharing) are all the ways tokens can be stolen.
6) Allow users to revoke a session
7) Allow multiple devices per logged in user
8) Anonymous sessions (to be thought about)
9) Easily allow advanced session operations like:
    - Limit number of devices a user can login with
    - Sync session data across devices
    - Keep user session data intact across login / logout (to be thought about)

## Implementation detail
This section highlights what the user will need to do in order to setup sessions. The aim here is to make it as simple and transparent to the user as possible.

## Default methodology:
#### Creation of a session
- After login, the backend will issue an opaque token. This will be a random, 32 character long `string`. The backend will also issue an anti-csrf token which will also be 32 characters long. The final access token will be a concatenation of these two strings. 
- This token will be sent to the frontend via `httpOnly`, `secure` cookies. If the user does not have `https` for their app, then they can switch off the secure flag via some config. Separately, the anti-csrf token will be sent to the frontend via response headers.
- The anti-csrf token must be stored in the localstorage on the frontend.
- The SHA256 hash of the access token will be stored in the database. This token will have the following properties mapped to it:
    - userId
    - anti-csrf token
    - expiry time
    - session data (this can be manipulated by the user).
- A cronjob will remove all expired tokens on a regular basis.

#### Session verification
- For each request that requires CSRF protection, the frontend must read the localstorage and send the anti-csrf token in the request header.
- An incoming access token can be verified by checking that it's in the db and that it has not expired. After each verification, the expiry time of the access token updated asynchronously (and in a lock free way).
- CSRF attack protection can be done checking that the incoming anti-csrf token (from the header) is what is associated with the session.
- Once verified, the API can easily get the userId associated with the session and also manipulate the session data.

#### Session revocation
- This is easily done by revoking a session from the database.
- This is also how user logout will be implemented. Furthermore, cookies will be cleared, and a header will be sent signalling to the frontend to remove the anti-csrf token from the localstorage

#### Authorisation
We want to be able to associate roles to sessions. There are many ways of doing this, but by default, we will allow just on role per session. This role information can be stored in the database along with the other session information.

We could have allowed a session to have multiple roles, but then this can easily cause conflicts and make the system vastly more complex. If the user needs to do this, they will have to use a third party service or build it themselves.

If a session's role changes, we should allow for the regeneration of the session token. This is a security best practice and is also recommended by OWASP.

## More secure methodology:
This is significantly more secure than the above, but it is slightly more inconvenient to the user than the above method because it requires refreshing of tokens.

#### Creation of a session
- After login, the backend will issue a short lived JWT (access token) and a long lived opaque token (called refresh token). An opaque token is a random string that doesn't mean anything. It only acts as a pointer to the session data stored in the database.
- The JWT will be generated by a shared secret key. This secret key will be automatically changed from time to time for security purposes. It is very important to keep this key secure, because if it is compromised, then an attacker can easily assume the identity of any user in the system.
- A hashed version of the opaque token will be stored in the database similar to the method described above.
- Both these tokens will be sent to the frontend client via `httpOnly` cookies. The `secure` flag should be set to `true` in case the user is using `https`. The access token will be sent to all APIs, whereas the refresh token will only be sent to the refresh API.
- The backend will also issue an anti-csrf token that is sent to the frontend via headers and is also a part of the JWT claims. This token is stored in the localstorage on the frontend.

#### Session verification
- The access token is sent for each API call.
- Verification is implemented by checking the signature of the JWT, as well as the expiration time.
- CSRF protection is done by checking the incoming anti-csrf token is the same as what's in the JWT. This can be disabled on a per API basis.

#### Session refreshing
- When the access token expires, a call needs to be made to the refresh API with the refresh token.
- If the refresh token is valid (not expired, and in the database), then a new JWT and a new refresh token is sent to the frontend.
- From a security point of view, it is important that we also send a new refresh token. If we do not do that, then this flow is the same as the previous flow (from a security point of view).

#### Session revocation


#### Authorisation
We want to be able to associate roles to sessions. There are many ways of doing this, but by default, we will allow just on role per session. This role information can be stored in the JWT access token.

We could have allowed a session to have multiple roles, but then this can easily cause conflicts and make the system vastly more complex. If the user needs to do this, they will have to use a third party service or build it themselves.

If a session's role changes, the access and the refresh token need to change.

#### Why is this slightly more inconvenient to the user that the previous method?


#### Why is this more secure than the default method?
This question is answered in [this blog post](https://supertokens.io/blog/all-you-need-to-know-about-user-session-security).



--------
questions:
- JWT or opaque in the secure method? Give user the choice?
- Give details on the exact algorithm of the secure method? It starts to get complex.
- I do not have a good enough mental model of how blitz frontend commnication works with the backend. But as a reference to how we have done it for SuperTokens, you can see our documentation for node and website, and then advice on which parts are good and not good for blitz app: [NodeJs docs](https://supertokens.io/docs/nodejs/installation), [Website SDK docs](https://supertokens.io/docs/website/installation).
- Anonymous session is not incorporated in these flows yet. But initial thoughts are that when someone visits a blitz website, then we want to allow to create a JWT based session for that anonymous user. This way, we will not use any db space (especially useful for high traffic sites with a high bounce rate). Session data will be stored in the JWT. If the developer wants to associate a lot of session data with that user, such that the JWT size results in cookies being more than 4kb, then we want to transparently store that extra information in the database and just have a reference to that in the JWT. But can we ignore this problem initially? The signing key of this JWT is different to the the one used when the user is logged in since this key cannot change in the same manner. 
- We should have a system for cron jobs. Most "serious" apps that I have built require at least one cron job for doing some business logic. Cron jobs will also be required for both the session flows mentioned above. Technically, we can still build it without cron jobs, but then there could be cases where a session may be in the database even after it has expired if the user never returns to that app. 