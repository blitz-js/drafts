# RFC 004: Blitz Session Management

## Objectives
1) Enable login and logout functionality.
2) Ability to easily set session inactivity timeout length (potentially for an "infinite" amount of time).
3) Easy to use
4) By default, prevent against:
    - CSRF: Can be switch off on a per endpoint basis.
    - XSS
    - Brute force
    - Database session theft: Even if an attacker gets the session tokens from the db, they should not be able to hijack those user's accounts.
5) Optionally provide significantly more security by detecting token theft as per [this RFC](https://tools.ietf.org/html/rfc6749#section-10.4). This will be inspired by [SuperTokens.io](https://supertokens.io?s=bl)'s implementation of sessions. [Here](https://docs.google.com/spreadsheets/d/14h9qd2glE31HSGUofx43XwfJHZNzgkdCwEKl-3UcXLE/edit?usp=sharing) are all the ways tokens can be stolen.
6) Allow users to revoke a session
7) Allow multiple devices per logged in user
8) Anonymous sessions (to be thought about)
9) Easily allow advanced session operations like:
    - Limit number of devices a user can login with
    - Sync session data across devices
    - Keep user session data intact across login / logout (to be thought about)

## Default methodology:
#### Creation of a session
- After login, the backend will issue an opaque token. This will be a random, 32 character long `string`. The backend will also issue an anti-csrf token which will also be 32 characters long. The final access token will be a concatenation of these two strings. 
- This token will be sent to the frontend via `httpOnly`, `secure` cookies. If the user does not have `https` for their app, then they can switch off the secure flag via some config. Separately, the anti-csrf token will be sent to the frontend via response headers.
- The anti-csrf token must be stored in the localstorage on the frontend.
- The SHA256 hash of the access token will be stored in the database. This token will have the following properties mapped to it:
    - userId
    - anti-csrf token
    - expiry time
    - session data (this can be manipulated by the user).
- A cronjob will remove all expired tokens on a regular basis.
- Creating a new session while another one exists results in the headers / cookies changing. However, the older session will still be alive.

#### Session verification
- For each request that requires CSRF protection, the frontend must read the localstorage and send the anti-csrf token in the request header.
- An incoming access token can be verified by checking that it's in the db and that it has not expired. After each verification, the expiry time of the access token updated asynchronously (and in a lock free way).
- CSRF attack protection can be done checking that the incoming anti-csrf token (from the header) is what is associated with the session.
- Once verified, the API can easily get the userId associated with the session and also manipulate the session data.

#### Session revocation
- This is easily done by revoking a session from the database.
- This is also how user logout will be implemented. Furthermore, cookies will be cleared, and a header will be sent signalling to the frontend to remove the anti-csrf token from the localstorage

#### Authorisation
We want to be able to associate roles to sessions. There are many ways of doing this, but by default, we will allow just on role per session. This role information can be stored in the database along with the other session information.

We could have allowed a session to have multiple roles, but then this can easily cause conflicts and make the system vastly more complex. If the user needs to do this, they will have to use a third party service or build it themselves.

If a session's role changes, we should allow for the regeneration of the session token. This is a security best practice and is also recommended by OWASP.

## More secure methodology:
This is significantly more secure than the above, but it is slightly more inconvenient to the user than the above method because it requires refreshing of tokens.

#### Creation of a session
- After login, the backend will issue a short lived JWT (access token) and a long lived opaque token (called refresh token). An opaque token is a random string that doesn't mean anything. It only acts as a pointer to the session data stored in the database.
- The JWT will be generated by a shared secret key. This secret key will be automatically changed from time to time for security purposes. It is very important to keep this key secure, because if it is compromised, then an attacker can easily assume the identity of any user in the system.
- A hashed version of the opaque token will be stored in the database similar to the method described above.
- Both these tokens will be sent to the frontend client via `httpOnly` cookies. The `secure` flag should be set to `true` in case the user is using `https`. The access token will be sent to all APIs, whereas the refresh token will only be sent to the refresh API.
- The backend will also issue an anti-csrf token that is sent to the frontend via headers and is also a part of the JWT claims. This token is stored in the localstorage on the frontend.

#### Session verification
- The access token is sent for each API call.
- Verification is implemented by checking the signature of the JWT, as well as the expiration time.
- CSRF protection is done by checking the incoming anti-csrf token is the same as what's in the JWT. This can be disabled on a per API basis.

#### Session refreshing
- When the access token expires, a call needs to be made to the refresh API with the refresh token.
- If the refresh token is valid (not expired, and in the database), then a new JWT and a new refresh token is sent to the frontend.
- From a security point of view, it is important that we also send a new refresh token. If we do not do that, then this flow is the same as the previous flow (from a security point of view).

#### Session revocation
- This is easily done by revoking the refresh session from the database.
- This is also how user logout will be implemented. Furthermore, cookies will be cleared, and a header will be sent signalling to the frontend to remove the anti-csrf token from the localstorage.
- Because we are using JWTs, technically, the session is not completely revoked immediately. A malicious user can still access the APIs with that JWT. Once the JWT expires (which has a very short lifetime), then the session will be completely revoked. This seems to provide a good balance between security and scalability. The alternative is to use opaque tokens instead of JWTs as the access token.

#### Authorisation
We want to be able to associate roles to sessions. There are many ways of doing this, but by default, we will allow just on role per session. This role information can be stored in the JWT access token.

We could have allowed a session to have multiple roles, but then this can easily cause conflicts and make the system vastly more complex. If the user needs to do this, they will have to use a third party service or build it themselves.

If a session's role changes, the access and the refresh token need to change.

#### Why is this slightly more inconvenient to the user that the previous method?
For server side rendering, we require the access token in almost all backend calls that result from a browser navigation. If the access token is expired / missing, then these API calls cannot function without refreshing the session.

However, the refresh token is not available to these calls. The only way to refresh the session is to send some code to the frontend (JS & HTML that shows a spinner) that will call the refresh API, and on success redirect the page and call this API again (this time with a valid access token).

This extra implementation detail can be handled automatically by the framework in client side rendered apps, but not in server side rendered apps since it requires UI input.


#### Why is this more secure than the default method?
This question is answered in this 2 part [blog post](https://supertokens.io/blog/all-you-need-to-know-about-user-session-security). This method also detects session hijacking which can occur in all the following ways as mentioned [here](https://docs.google.com/spreadsheets/d/14h9qd2glE31HSGUofx43XwfJHZNzgkdCwEKl-3UcXLE/edit?usp=sharing).

## Implementation detail for the default methodology
### Init
If we can have default values for all config params, then the user does not have to call this init function (unless they want to change the defaults). The params for this will be discussed in the "Config params" section below.
```ts
import Session from 'blitz-supertokens'
// on app start

Session.init({
    // config params
});
```

### Session middleware
A middleware will manage the verification of a session. **The user does not have to implement this middleware.**

```ts
// /some/path/special.ts
import {Context, ApiRequest, ApiResponse} from 'blitz/types'
import Session from 'blitz-supertokens'

type SessionType = { 
    userId?: string,
    role: string,  // will be "public" if session is anonymous. If the user does not specify a role, the default value will be "genericUser"
    create: (userId: string, role?: string, sessionDataInDb?: Object, infoThatFrontendCanRead?: Object) => Promise<SessionType>,
    revoke: () => Promise<void>,    // if anonymous, this will fo nothing.
    getData: () => Promise<object>,
    setData: (data: object) => Promise<void>,
    handle: string
}

export const middleware = [
  (req: NextApiRequest, res: NextApiResponse): SessionType => {
    try {
        let enableCsrfProtection = req.method !== "GET";
        
        return await Session.getSession(req, res, enableCsrfProtection);
    } catch (err) {
        if (err.type === Session.Error.UNAUTHORISED) {
            if (/* Error due to CSRF check failing*/) {
                throw new AntiCSRFTokenFailure();
            }
        } else {
            throw err;
        }
    }

    // we want to create an anonymous JWT based session.
    // the role here will be "public"
    return Session.createAnonymousSession(req, res);
  }
]

type SpecialContext = Context & SessionType
```


### User login
```ts
// /some/path/login.ts

export default async function login(args: UserCredentials, ctx: Context) {
    // Verify that UserCredentials are correct.
    let userId = // get userId from DB

    let infoThatFrontendCanRead = {
        // ...
    };

    let sessionDataInDb = {
        // ...
    };

    try {
        await ctx.session.create(userId, "admin", sessionDataInDb, infoThatFrontendCanRead);

        // successfully created a session.
    } catch (err) {
        // log and throw an error
    }
}
```

### Getting userId, setting and getting session data
```ts
// /some/path/example.ts

export default async function exampleQuery(args: SomArgs, ctx: Context) {
    if (ctx.session.role !== "public") {
       let userId = ctx.session.userId;
    }
    let data = await ctx.session.getData();

    let newData = {
        ...data,
        newKey: "newVal"
    };

    await ctx.session.setData(newData);
}
```

### Revoking a session
```ts
// /some/path/example.ts

export default async function exampleQuery(args: SomArgs, ctx: Context) {

    // the following will take care of clearing all cookies.
    // for anonymous sessions, this is a noop.

    // if the session does not exist, the function below will not throw any error.
    await ctx.session.revoke();
}
```

### Using session handle
TODO

### TODO
- Anonymous session
- Compatibility of secure and default method so that the user can switch anytime
- Authorisation / user roles.
- Session token regeneration


## Implementation detail for the more secure methodology
TODO

## Config params
#### Default methodology
TODO

#### More secure methodology
TODO

## Frontend requirements
TODO